// SPDX-FileCopyrightText: © 2025 Mislav Marohnić <hi@mislav.net>
//
// SPDX-License-Identifier: AGPL-3.0-only

package contents

import (
	"iter"
	"log/slog"
	"net/url"
	"strings"
	"unicode"

	"codeberg.org/readeck/readeck/pkg/extract"
	"github.com/go-shiori/dom"
	"golang.org/x/net/html"
)

// StripHeadingAnchors removes self-linking heading hyperlinks that are auto-generated by some
// content publishing platforms. The contents of the links are unwrapped, except when they contain a
// single character or icon, in which the link is completely removed.
func StripHeadingAnchors(m *extract.ProcessMessage, next extract.Processor) extract.Processor {
	if m.Step() != extract.StepDom || m.Dom == nil {
		return next
	}

	numStripped := 0
	for href, a := range eachHyperlink(m.Dom) {
		if !strings.HasPrefix(href, "#") {
			continue
		}
		fragmentID := unescape(href[1:])
		if strings.HasPrefix(fragmentID, "/") {
			// Handle Docsify hash router URLs of the format `#/path?id=fragment`
			// Conveniently, the "data-id" attribute contains just the fragment part.
			if dataID := dom.GetAttribute(a, "data-id"); dataID != "" {
				fragmentID = dataID
			}
		}

		isAnchor := false
		var headingElement *html.Node
		for el := range traverseAdjacent(a) {
			elementID := unescape(dom.GetAttribute(el, "id"))
			if len(elementID) > 0 && elementID == fragmentID || strings.TrimPrefix(elementID, "user-content-") == fragmentID {
				isAnchor = true
			}
			switch el.Data {
			case "h1", "h2", "h3", "h4", "h5", "h6":
				headingElement = el
			}
			if isAnchor && headingElement != nil {
				if !containsSingleIcon(a) {
					unwrapElement(a)
				}
				if aID := dom.GetAttribute(a, "id"); aID != "" && !dom.HasAttribute(headingElement, "id") {
					// The <a id="..."> element is going away, so preserve its ID attribute by
					// moving it onto the heading element.
					dom.SetAttribute(headingElement, "id", aID)
				}
				a.Parent.RemoveChild(a)
				numStripped++
				break
			}
		}
	}

	m.Log().Debug("strip heading anchors", slog.Int("nodes", numStripped))

	return next
}

func containsSingleIcon(a *html.Node) bool {
	child := a.FirstChild
	if child == nil || child.NextSibling != nil {
		return false
	}
	if child.Type == html.ElementNode {
		return child.Data == "svg" ||
			child.Data == "img" ||
			isHiddenElement(child) ||
			containsSingleIcon(child)
	}
	if child.Type != html.TextNode {
		return false
	}

	// Check if the link text is a single character or icon
	var firstRune rune
	for idx, r := range child.Data {
		if idx > 0 {
			return false
		}
		firstRune = r
	}
	switch firstRune {
	// Common section character icons, zero-width space for VitePress, chain link emoji, paperclip emoji
	case '#', '¶', '§', '\u200B', 0x1f517, 0x1f4ce:
		return true
	default:
		// Font Awesome icons are assigned codepoints in the Unicode "Private Use" category
		return unicode.Is(unicode.Co, firstRune)
	}
}

func isHiddenElement(el *html.Node) bool {
	for _, attr := range el.Attr {
		if attr.Key == "aria-hidden" {
			return attr.Val == "" || attr.Val == "true"
		}
	}
	return false
}

// Iterates through every <a href> element in the given DOM and yields the href value and the <a>
// element node. The yielded node is safe to detach from the DOM mid-iteration.
func eachHyperlink(node *html.Node) iter.Seq2[string, *html.Node] {
	return func(yield func(string, *html.Node) bool) {
		var traverse func(*html.Node) bool
		traverse = func(n *html.Node) bool {
			for child := n.FirstChild; child != nil; {
				nextSibling := child.NextSibling
				if child.Type == html.ElementNode {
					if child.Data == "a" {
						for _, attr := range child.Attr {
							if attr.Key == "href" {
								if !yield(attr.Val, child) {
									return false
								}
							}
						}
					} else if !traverse(child) {
						return false
					}
				}
				child = nextSibling
			}
			return true
		}
		_ = traverse(node)
	}
}

// Traverses adjacent node elements: self, the closest two ancestors, and previous and next element siblings.
func traverseAdjacent(node *html.Node) iter.Seq[*html.Node] {
	return func(yield func(*html.Node) bool) {
		ancestor := node
		for depth := 0; ancestor != nil && depth < 3; depth++ {
			if ancestor.Type == html.ElementNode && !yield(ancestor) {
				return
			}
			ancestor = ancestor.Parent
		}
		if prevElement := dom.PreviousElementSibling(node); prevElement != nil && !yield(prevElement) {
			return
		}
		if nextElement := dom.NextElementSibling(node); nextElement != nil && !yield(nextElement) {
			return
		}
	}
}

// Unwrap an HTML element by reparenting its contents.
func unwrapElement(node *html.Node) {
	for c := node.FirstChild; c != nil; {
		nextSibling := c.NextSibling
		dom.DetachChild(c)
		node.Parent.InsertBefore(c, node)
		c = nextSibling
	}
}

func unescape(s string) string {
	if len(s) == 0 {
		return ""
	}
	if val, err := url.QueryUnescape(s); err == nil {
		return val
	}
	return s
}
