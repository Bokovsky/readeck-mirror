// SPDX-FileCopyrightText: © 2025 Mislav Marohnić <hi@mislav.net>
//
// SPDX-License-Identifier: AGPL-3.0-only

package contents

import (
	"net/url"
	"strings"
	"unicode"

	"codeberg.org/readeck/readeck/pkg/extract"
	"github.com/go-shiori/dom"
	"golang.org/x/net/html"
)

// StripHeadingAnchors removes self-linking heading hyperlinks that are auto-generated by some
// content publishing platforms. The contents of the links are unwrapped, except when they contain a
// single character or icon, in which the link is completely removed.
func StripHeadingAnchors(m *extract.ProcessMessage, next extract.Processor) extract.Processor {
	if m.Step() != extract.StepDom || m.Dom == nil {
		return next
	}

	m.Log().Debug("strip heading anchors")

	var traverse func(*html.Node)
	traverse = func(n *html.Node) {
		for child := n.FirstChild; child != nil; {
			if child.Type == html.ElementNode && child.Data == "a" {
				a := child
				if isHeadingAnchor(a) {
					if !containsSingleIcon(a) {
						// Unwrap the <a> element by reparenting its contents
						for c := a.FirstChild; c != nil; {
							nextSibling := c.NextSibling
							dom.DetachChild(c)
							a.Parent.InsertBefore(c, a)
							c = nextSibling
						}
					}
					child = child.NextSibling
					a.Parent.RemoveChild(a)
					continue
				}
			}
			traverse(child)
			child = child.NextSibling
		}
	}
	traverse(m.Dom)

	return next
}

func isHeadingAnchor(a *html.Node) bool {
	href := dom.GetAttribute(a, "href")
	if !strings.HasPrefix(href, "#") {
		return false
	}
	fragment := unescape(href[1:])
	// handle Docsify fragment prefix:
	fragment = strings.TrimPrefix(fragment, "/?id=")

	isAnchor := false
	isHeading := false
	detect := func(node *html.Node) {
		if node == nil || node.Type != html.ElementNode {
			return
		}
		id := unescape(dom.GetAttribute(node, "id"))
		if len(id) > 0 && id == fragment || strings.TrimPrefix(id, "user-content-") == fragment {
			isAnchor = true
		}
		switch node.Data {
		case "h1", "h2", "h3", "h4", "h5", "h6":
			isHeading = true
		}
	}

	ancestor := a
	for depth := 0; ancestor != nil && depth < 3; depth++ {
		detect(ancestor)
		ancestor = ancestor.Parent
	}
	if !isHeading {
		detect(a.PrevSibling)
	}
	if !isHeading {
		detect(a.NextSibling)
	}

	return isAnchor && isHeading
}

func containsSingleIcon(a *html.Node) bool {
	child := a.FirstChild
	if child == nil || child.NextSibling != nil {
		return false
	}
	if child.Type == html.ElementNode {
		return child.Data == "svg" || child.Data == "img" || containsSingleIcon(child)
	}
	if child.Type != html.TextNode {
		return false
	}

	// Check if the link text is a single character or icon
	var firstRune rune
	for idx, r := range child.Data {
		if idx > 0 {
			return false
		}
		firstRune = r
	}
	switch firstRune {
	// Common section character icons, zero-width space for VitePress, chain link emoji
	case '#', '¶', '§', '\u200B', 0x1f517:
		return true
	default:
		// Font Awesome icons are assigned codepoints in the Unicode "Private Use" category
		return unicode.Is(unicode.Co, firstRune)
	}
}

func unescape(s string) string {
	if len(s) == 0 {
		return ""
	}
	if val, err := url.QueryUnescape(s); err == nil {
		return val
	}
	return s
}
